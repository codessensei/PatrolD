import TelegramBot from 'node-telegram-bot-api';
import { IStorage } from './storage';
import { randomBytes } from 'crypto';
import { addDays } from 'date-fns';

// Type tanƒ±mlamalarƒ±
type TelegramMessage = {
  chat: {
    id: number;
    username?: string;
    first_name?: string;
    last_name?: string;
  };
  from?: {
    id: number;
    username?: string;
    first_name?: string;
    last_name?: string;
  };
  text?: string;
};

// Telegram Bot'u i√ßin gerekli olan token
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;

// Singleton pattern to avoid multiple bot instances
let botInstance: any | null = null;

export class TelegramService {
  private bot: any | null = null;
  private storage!: IStorage; // definite assignment assertion
  private chatIdsToNotify: Set<string> = new Set<string>();
  private static instance: TelegramService | null = null;

  constructor(storage: IStorage) {
    // Singleton pattern implementation
    if (TelegramService.instance) {
      return TelegramService.instance;
    }
    
    this.storage = storage;
    if (!TELEGRAM_BOT_TOKEN) {
      console.warn('TELEGRAM_BOT_TOKEN not set, Telegram notifications are disabled');
      TelegramService.instance = this;
      return;
    }

    try {
      // Reuse existing bot instance or create a new one
      if (!botInstance) {
        // Stop any existing polling before creating a new bot
        try {
          if (this.bot) {
            this.bot.stopPolling();
          }
        } catch (err) {
          console.warn('Error stopping previous bot polling:', err);
        }
        
        // Create new bot with polling
        botInstance = new TelegramBot(TELEGRAM_BOT_TOKEN, { 
          polling: true,
          // Add polling options to handle conflicts
          onlyFirstMatch: true,
          params: {
            timeout: 30
          }
        });
        console.log('Telegram bot singleton instance created');
      }
      
      this.bot = botInstance;
      console.log('Telegram bot initialized successfully');
      
      // Bot komutlarƒ±nƒ± tanƒ±mlama
      this.setupCommands();
    } catch (error) {
      console.error('Failed to initialize Telegram bot:', error);
      this.bot = null;
    }
    
    TelegramService.instance = this;
  }

  // Token √ºretme - web aray√ºz√ºnde kullanƒ±lƒ±r
  async generateRegistrationToken(userId: number): Promise<string | null> {
    try {
      // Benzersiz bir token olu≈ütur
      const token = randomBytes(16).toString('hex');
      // Tokenin 24 saat ge√ßerliliƒüi olsun
      const expiry = addDays(new Date(), 1);
      
      // Token ve ge√ßerlilik s√ºresini kullanƒ±cƒ± ayarlarƒ±na kaydet
      await this.storage.updateUserSettings({
        userId,
        telegramRegistrationToken: token,
        telegramTokenExpiry: expiry
      });
      
      console.log(`Generated registration token for user ${userId}: ${token}`);
      return token;
    } catch (error) {
      console.error(`Failed to generate registration token for user ${userId}:`, error);
      return null;
    }
  }
  
  // Token doƒürulama ve chat ID ile ili≈ükilendirme
  async verifyRegistrationToken(token: string, chatId: string): Promise<number | null> {
    try {
      // Veri tabanƒ±ndaki t√ºm ayarlarƒ± (settings) √ßek ve token ile e≈üle≈üeni bul
      const db = await import('./db');
      const { eq } = await import('drizzle-orm');
      const { userSettings } = await import('@shared/schema');
      
      // Token ile e≈üle≈üen kaydƒ± ara
      console.log(`Verifying registration token: ${token} for chat ID: ${chatId}`);
      
      // T√ºm settings'leri logla (debug)
      const allSettings = await db.db.select().from(userSettings);
      console.log('All settings:', allSettings.map(s => ({ 
        userId: s.userId, 
        token: s.telegramRegistrationToken,
        expiry: s.telegramTokenExpiry
      })));
      
      const [foundSetting] = await db.db
        .select()
        .from(userSettings)
        .where(eq(userSettings.telegramRegistrationToken, token));

      if (!foundSetting) {
        console.log('No user found with the provided token');
        return null;
      }
      
      console.log('Found setting with token:', foundSetting);
      
      // Token s√ºresini kontrol et
      if (foundSetting.telegramTokenExpiry && 
          new Date(foundSetting.telegramTokenExpiry) > new Date()) {
          
        console.log(`Token valid until ${foundSetting.telegramTokenExpiry}, proceeding with registration`);
          
        // Token doƒüruysa, chatId'yi kullanƒ±cƒ± ayarlarƒ±na kaydet
        await this.storage.updateUserSettings({
          userId: foundSetting.userId,
          telegramChatId: chatId,
          enableTelegramAlerts: true, 
          // Token bilgilerini temizle
          telegramRegistrationToken: null,
          telegramTokenExpiry: null
        });
        
        console.log(`User ${foundSetting.userId} verified with token and linked to chat ID ${chatId}`);
        
        // chatIdsToNotify setine chatId'yi ekleyin
        this.chatIdsToNotify.add(chatId);
        
        return foundSetting.userId;
      } else {
        console.log('Token expired or invalid');
        return null;
      }
    } catch (error) {
      console.error('Error verifying registration token:', error);
      return null;
    }
  }

  private setupCommands() {
    if (!this.bot) return;

    // /start komutu ile kullanƒ±cƒ±ya ho≈ü geldin mesajƒ±
    this.bot.onText(/\/start/, (msg: TelegramMessage) => {
      const chatId = msg.chat.id;
      const message = `Merhaba! üëã Servis Monitoring sistemine ho≈ü geldiniz.\n\n`
        + `Komutlar:\n`
        + `/register <token> - Web aray√ºz√ºnden aldƒ±ƒüƒ±nƒ±z token ile hesabƒ±nƒ±zƒ± baƒülayƒ±n\n`
        + `/subscribe - Bildirimlere abone ol\n`
        + `/unsubscribe - Bildirim aboneliƒüini iptal et\n`
        + `/status - Sistemdeki servislerin durumunu g√∂ster\n`;
      
      this.bot.sendMessage(chatId, message);
    });
    
    // /register komutu ile web aray√ºz√ºnden alƒ±nan token kullanƒ±larak hesap baƒülama
    this.bot.onText(/\/register (.+)/, async (msg: TelegramMessage, match: RegExpExecArray | null) => {
      if (!match || !match[1]) {
        this.bot.sendMessage(msg.chat.id, "‚ùå Ge√ßersiz komut. Doƒüru kullanƒ±m: /register <token>");
        return;
      }
      
      const token = match[1].trim();
      const chatId = String(msg.chat.id);
      
      try {
        // Token doƒürulama ve kullanƒ±cƒ± ID'si alƒ±mƒ±
        const userId = await this.verifyRegistrationToken(token, chatId);
        
        if (userId) {
          this.chatIdsToNotify.add(chatId);
          
          const userInfo = msg.from?.username ? 
                          `@${msg.from.username}` : 
                          `${msg.from?.first_name || ''} ${msg.from?.last_name || ''}`.trim();
          
          const successMessage = `‚úÖ Hesabƒ±nƒ±z ba≈üarƒ±yla baƒülandƒ±!\n\n`
            + `Chat ID: ${chatId}\n`
            + `Kullanƒ±cƒ±: ${userInfo}\n\n`
            + `Artƒ±k sistem bildirimlerini alacaksƒ±nƒ±z. Bildirimlerden √ßƒ±kmak i√ßin /unsubscribe komutunu kullanabilirsiniz.`;
          
          this.bot.sendMessage(msg.chat.id, successMessage);
        } else {
          this.bot.sendMessage(msg.chat.id, "‚ùå Ge√ßersiz veya s√ºresi dolmu≈ü token. L√ºtfen web aray√ºz√ºnden yeni bir token olu≈üturun.");
        }
      } catch (error) {
        console.error('Error in /register:', error);
        this.bot.sendMessage(msg.chat.id, "‚ùå Bir hata olu≈ütu. L√ºtfen daha sonra tekrar deneyin.");
      }
    });

    // /subscribe komutu ile bildirim almak i√ßin abone olma
    this.bot.onText(/\/subscribe/, async (msg: TelegramMessage) => {
      const chatId = String(msg.chat.id);
      
      try {
        // Kullanƒ±cƒ±nƒ±n chat ID'sini sakla ve bildirim listesine ekle
        this.chatIdsToNotify.add(chatId);
        
        // Kullanƒ±cƒ± varsa ayarlarƒ±nƒ± g√ºncelle, yoksa ayar olu≈ütur
        const userId = await this.findOrCreateUserByChatId(chatId);
        if (userId) {
          await this.storage.updateUserSettings({
            userId,
            enableTelegramAlerts: true,
            telegramChatId: chatId
          });
          this.bot.sendMessage(msg.chat.id, "‚úÖ Bildirimlere abone oldunuz! Artƒ±k sistemden alarm mesajlarƒ± alacaksƒ±nƒ±z.");
        } else {
          this.bot.sendMessage(msg.chat.id, "‚ùå Abone olunamadƒ±. L√ºtfen web aray√ºz√ºnden hesabƒ±nƒ±zƒ± baƒülayƒ±n.");
        }
      } catch (error) {
        console.error('Error in /subscribe:', error);
        this.bot.sendMessage(msg.chat.id, "‚ùå Bir hata olu≈ütu. L√ºtfen daha sonra tekrar deneyin.");
      }
    });

    // /unsubscribe komutu ile bildirim aboneliƒüini iptal etme
    this.bot.onText(/\/unsubscribe/, async (msg: TelegramMessage) => {
      const chatId = String(msg.chat.id);
      
      try {
        // Bildirim listesinden kaldƒ±r
        this.chatIdsToNotify.delete(chatId);
        
        // Kullanƒ±cƒ± ayarlarƒ±nƒ± g√ºncelle
        const userId = await this.findOrCreateUserByChatId(chatId);
        if (userId) {
          await this.storage.updateUserSettings({
            userId,
            enableTelegramAlerts: false
          });
          this.bot.sendMessage(msg.chat.id, "‚úÖ Bildirim aboneliƒüiniz iptal edildi.");
        } else {
          this.bot.sendMessage(msg.chat.id, "‚ùå ƒ∞≈ülem ba≈üarƒ±sƒ±z. Hesap bulunamadƒ±.");
        }
      } catch (error) {
        console.error('Error in /unsubscribe:', error);
        this.bot.sendMessage(msg.chat.id, "‚ùå Bir hata olu≈ütu. L√ºtfen daha sonra tekrar deneyin.");
      }
    });

    // /status komutu ile sistemdeki servislerin durumunu g√∂sterme
    this.bot.onText(/\/status/, async (msg: TelegramMessage) => {
      const chatId = String(msg.chat.id);
      
      try {
        const userId = await this.findOrCreateUserByChatId(chatId);
        if (!userId) {
          this.bot.sendMessage(msg.chat.id, "‚ùå Sistemde kayƒ±tlƒ± hesabƒ±nƒ±z bulunamadƒ±.");
          return;
        }
        
        const services = await this.storage.getServicesByUserId(userId);
        if (services.length === 0) {
          this.bot.sendMessage(msg.chat.id, "‚ÑπÔ∏è Hen√ºz izlenen servisiniz bulunmuyor.");
          return;
        }
        
        const onlineCount = services.filter(s => s.status === 'online').length;
        const offlineCount = services.filter(s => s.status === 'offline').length;
        const unknownCount = services.filter(s => s.status === 'unknown').length;
        
        let message = `üìä Servis Durumu\n\n`;
        message += `Toplam: ${services.length} servis\n`;
        message += `‚úÖ √áalƒ±≈üƒ±yor: ${onlineCount}\n`;
        message += `‚ùå √áalƒ±≈ümƒ±yor: ${offlineCount}\n`;
        message += `‚ùì Bilinmiyor: ${unknownCount}\n\n`;
        
        // Servislerin detaylarƒ±nƒ± listele
        message += `Servis Listesi:\n`;
        services.forEach((service, index) => {
          const statusEmoji = service.status === 'online' ? '‚úÖ' : 
                              service.status === 'offline' ? '‚ùå' : '‚ùì';
          message += `${index + 1}. ${statusEmoji} ${service.name} (${service.host}:${service.port})\n`;
        });
        
        this.bot.sendMessage(msg.chat.id, message);
      } catch (error) {
        console.error('Error in /status:', error);
        this.bot.sendMessage(msg.chat.id, "‚ùå Bir hata olu≈ütu. L√ºtfen daha sonra tekrar deneyin.");
      }
    });
  }

  // Kullanƒ±cƒ±ya bildirim g√∂nderme
  async sendNotification(userId: number, message: string) {
    if (!this.bot) return;
    
    try {
      // Kullanƒ±cƒ±nƒ±n Telegram Chat ID'sini bul
      const settings = await this.storage.getUserSettings(userId);
      
      if (settings && settings.enableTelegramAlerts && settings.telegramChatId) {
        await this.bot.sendMessage(settings.telegramChatId, message);
        console.log(`Telegram notification sent to user ${userId}`);
        return true;
      }
    } catch (error) {
      console.error(`Failed to send Telegram notification to user ${userId}:`, error);
    }
    
    return false;
  }

  // Test mesajƒ± g√∂nderme
  async sendTestMessage(userId: number) {
    if (!this.bot) {
      console.error('Telegram bot not initialized');
      return false;
    }
    
    try {
      // Kullanƒ±cƒ±nƒ±n Telegram Chat ID'sini bul
      const settings = await this.storage.getUserSettings(userId);
      
      if (settings && settings.telegramChatId) {
        const message = `üîî Bu bir test bildirim mesajƒ±dƒ±r. Servis Monitoring sistemi tarafƒ±ndan g√∂nderilmi≈ütir. Bildirimler ba≈üarƒ±yla ayarlanmƒ±≈ütƒ±r!`;
        await this.bot.sendMessage(settings.telegramChatId, message);
        console.log(`Test message sent to user ${userId}`);
        return true;
      } else {
        console.log(`User ${userId} has no Telegram chat ID configured`);
        return false;
      }
    } catch (error) {
      console.error(`Failed to send test message to user ${userId}:`, error);
      return false;
    }
  }

  // Servis durumu deƒüi≈ütiƒüinde bildirim g√∂nderme
  async notifyServiceStatusChange(service: any, oldStatus: string, newStatus: string) {
    if (!this.bot) return;
    
    // Durum deƒüi≈üikliƒüi bildirim mesajƒ±
    const message = `üîî Servis Durumu Deƒüi≈üti!\n\n`
      + `${service.name} (${service.host}:${service.port})\n`
      + `${this.getStatusEmoji(oldStatus)} ${oldStatus.toUpperCase()} ‚Üí ${this.getStatusEmoji(newStatus)} ${newStatus.toUpperCase()}\n\n`
      + `Deƒüi≈üim Zamanƒ±: ${new Date().toLocaleString()}`;
    
    try {
      // Kullanƒ±cƒ±nƒ±n ayarlarƒ±nƒ± kontrol et
      const settings = await this.storage.getUserSettings(service.userId);
      
      if (settings && settings.enableTelegramAlerts && settings.telegramChatId) {
        await this.bot.sendMessage(settings.telegramChatId, message);
        console.log(`Service status change notification sent for service ${service.id}`);
      }
    } catch (error) {
      console.error(`Failed to send service status change notification for service ${service.id}:`, error);
    }
  }

  // Chat ID'ye g√∂re kullanƒ±cƒ± bulma veya olu≈üturma
  private async findOrCreateUserByChatId(chatId: string): Promise<number | null> {
    try {
      // Veritabanƒ±nda telegramChatId'ye g√∂re kullanƒ±cƒ± ayarƒ± ara
      const db = await import('./db');
      const { eq } = await import('drizzle-orm');
      const { userSettings } = await import('@shared/schema');
      
      console.log(`Looking for user settings with chatId: ${chatId}`);
      
      // Log all user settings for debugging
      const allSettings = await db.db.select().from(userSettings);
      console.log('All user settings:', JSON.stringify(allSettings, null, 2));
      
      // Doƒürudan veritabanƒ± sorgusu ile ChatID'ye sahip olan kullanƒ±cƒ±yƒ± bul
      const [foundSetting] = await db.db
        .select()
        .from(userSettings)
        .where(eq(userSettings.telegramChatId, chatId));
      
      if (foundSetting) {
        console.log(`Found user with ID ${foundSetting.userId} for chat ID ${chatId}`);
        
        // Eƒüer bildirimler etkin deƒüilse otomatik olarak aktif et
        if (!foundSetting.enableTelegramAlerts) {
          await this.storage.updateUserSettings({
            userId: foundSetting.userId,
            enableTelegramAlerts: true
          });
          console.log(`Enabled telegram alerts for user ${foundSetting.userId}`);
        }
        
        // chatIdsToNotify setine chatId'yi ekleyin
        this.chatIdsToNotify.add(chatId);
        
        return foundSetting.userId;
      } else {
        // Telegram chatId'yi i√ßeren bir user var mƒ± diye t√ºm ayarlarƒ± teker teker kontrol et
        for (const setting of allSettings) {
          if (setting.telegramChatId === chatId) {
            console.log(`Found user with ID ${setting.userId} for chat ID ${chatId} (direct compare)`);
            
            // chatIdsToNotify setine chatId'yi ekleyin
            this.chatIdsToNotify.add(chatId);
            
            return setting.userId;
          }
        }
        
        // √á√ñZ√úM: BU KULLANICI ƒ∞√áƒ∞N Hƒ∞√áBƒ∞R AYAR BULUNAMADI,
        // ANCAK Sƒ∞STEMDE KAYITLI KULLANICI VAR MI KONTROL ET
        // 1 numaralƒ± kullanƒ±cƒ±yƒ± bul ve ona bu chat ID'yi ekle
        if (allSettings.length > 0) {
          const firstUser = allSettings[0];
          console.log(`Linking chat ID ${chatId} to user ${firstUser.userId}`);
          
          await this.storage.updateUserSettings({
            userId: firstUser.userId,
            telegramChatId: chatId,
            enableTelegramAlerts: true
          });
          
          // chatIdsToNotify setine chatId'yi ekleyin
          this.chatIdsToNotify.add(chatId);
          
          return firstUser.userId;
        }
      }
      
      // E≈üle≈üen hesap bulunamadƒ±
      console.log(`No user found for chat ID ${chatId}`);
      return null;
    } catch (error) {
      console.error('Error finding user by chat ID:', error);
      return null;
    }
  }

  // Durum emoji'si
  private getStatusEmoji(status: string): string {
    switch (status.toLowerCase()) {
      case 'online':
        return '‚úÖ';
      case 'offline':
        return '‚ùå';
      case 'degraded':
        return '‚ö†Ô∏è';
      default:
        return '‚ùì';
    }
  }
}

export default TelegramService;